{"version":3,"sources":["../src/index.ts","../src/Tromero.ts","../src/openai/streaming.ts","../src/openai/mergeChunks.ts","../src/Tromero_Client.ts"],"sourcesContent":["import TailorAI from './Tromero';\n\nexport default TailorAI;\n","import * as openai from 'openai';\nimport * as Core from 'openai/core';\nimport type { Stream } from 'openai/streaming';\nimport type {\n  ChatCompletion,\n  ChatCompletionChunk,\n  ChatCompletionCreateParams,\n  ChatCompletionCreateParamsBase,\n  ChatCompletionCreateParamsNonStreaming,\n  ChatCompletionCreateParamsStreaming,\n} from 'openai/resources/chat/completions';\nimport {\n  Choice,\n  Message,\n  mockOpenAIFormat,\n  TromeroCompletionArgs,\n} from './tromeroUtils';\nimport { MockStream } from './openai/streaming';\nimport TromeroClient from './Tromero_Client';\n\ninterface TromeroOptions extends openai.ClientOptions {\n  apiKey?: string;\n  tromeroKey: string | undefined;\n  saveData?: boolean;\n}\n\nexport default class Tromero extends openai.OpenAI {\n  public tromeroClient?: TromeroClient;\n\n  constructor({ tromeroKey, apiKey, ...opts }: TromeroOptions) {\n    super({ apiKey, ...opts });\n\n    if (tromeroKey) {\n      const tromeroClient = new TromeroClient({ apiKey: tromeroKey });\n      this.chat.setClient(tromeroClient);\n    } else {\n      if (apiKey) {\n        console.warn(\n          \"You're using the Tromero client without an API key. While OpenAI requests will still go through, Tromero requests will fail, and no data will be saved.\"\n        );\n      } else {\n        console.warn(\n          \"You haven't set an apiKey for OpenAI or a tromeroKey for Tromero. Please set one of these to use the client.\"\n        );\n      }\n    }\n  }\n\n  chat: MockChat = new MockChat(this);\n}\n\nclass MockChat extends openai.OpenAI.Chat {\n  completions: MockCompletions;\n\n  constructor(client: openai.OpenAI) {\n    super(client);\n    this.completions = new MockCompletions(client);\n  }\n\n  setClient(client: TromeroClient) {\n    this.completions.setTromeroClient(client);\n  }\n}\n\nclass MockCompletions extends openai.OpenAI.Chat.Completions {\n  openaiClient: openai.OpenAI;\n  tromeroClient: TromeroClient | undefined;\n\n  constructor(client: openai.OpenAI) {\n    super(client);\n    this.openaiClient = client;\n  }\n\n  setTromeroClient(client: TromeroClient) {\n    this.tromeroClient = client;\n  }\n  private choiceToDict(choice: Choice): Choice {\n    return {\n      message: {\n        content: choice.message.content,\n        role: choice.message.role,\n      },\n    };\n  }\n\n  private async saveDataOnServer(\n    saveData: boolean,\n    data: any\n  ): Promise<string> {\n    try {\n      if (saveData && this.tromeroClient) {\n        setTimeout(() => this.tromeroClient!.postData(data), 0);\n      }\n    } catch (error) {}\n    return '';\n  }\n\n  private async formatKwargs(kwargs: { [key: string]: any }): Promise<{\n    formattedKwargs: { [key: string]: any };\n    openAiKwargs: { [key: string]: any };\n  }> {\n    const keysToKeep = [\n      'best_of',\n      'decoder_input_details',\n      'details',\n      'do_sample',\n      'max_tokens',\n      'ignore_eos_token',\n      'repetition_penalty',\n      'return_full_outcome',\n      'seed',\n      'stop',\n      'temperature',\n      'top_k',\n      'top_p',\n      'truncate',\n      'typical_p',\n      'watermark',\n      'schema',\n      'adapter_id',\n      'adapter_source',\n      'merged_adapters',\n      'response_format',\n    ];\n\n    const additionalKeys = [\n      'tags',\n      'model',\n      'messages',\n      'use_fallback',\n      'fallback_model',\n      'stream',\n    ];\n\n    const validKeys = new Set([...keysToKeep, ...additionalKeys]);\n    const formattedKwargs: { [key: string]: any } = {};\n    const openAiKwargs: { [key: string]: any } = {};\n\n    let invalidKeyFound = false;\n\n    for (const key in kwargs) {\n      if (validKeys.has(key)) {\n        formattedKwargs[key] = kwargs[key];\n      } else {\n        console.warn(\n          `Warning: ${key} is not a valid parameter for the model. This parameter will be ignored.`\n        );\n        invalidKeyFound = true;\n      }\n\n      if (keysToKeep.includes(key)) {\n        openAiKwargs[key] = kwargs[key];\n      }\n    }\n\n    if (invalidKeyFound) {\n      console.log(\n        'The following parameters are valid for the model: ',\n        keysToKeep.join(', ')\n      );\n    }\n    return { formattedKwargs, openAiKwargs };\n  }\n\n  private formatMessages(messages: Message[]): Message[] {\n    let systemPrompt = '';\n    let numPrompts = 0;\n\n    for (const message of messages) {\n      if (message.role === 'system') {\n        systemPrompt += message.content + ' ';\n        numPrompts += 1;\n      } else {\n        break;\n      }\n    }\n\n    if (numPrompts <= 1) {\n      return messages;\n    }\n\n    const combinedMessage: Message = {\n      role: 'system',\n      content: systemPrompt.trim(),\n    };\n    const remainingMessages = messages.slice(numPrompts);\n\n    console.warn(\n      'Warning: Multiple system prompts will be combined into one prompt when saving data or calling custom models.'\n    );\n\n    return [combinedMessage, ...remainingMessages];\n  }\n\n  private async isModelFromOpenAi(model: string): Promise<boolean> {\n    try {\n      const models = await this._client.models.list();\n      const modelNames = models.data.map((m: any) => m.id);\n      return modelNames.includes(model);\n    } catch (error) {\n      console.warn(\"Error in retrieving OpenAi's model list\");\n      return false;\n    }\n  }\n\n  _create(\n    body: ChatCompletionCreateParamsNonStreaming,\n    options?: Core.RequestOptions\n  ): Core.APIPromise<ChatCompletion>;\n  _create(\n    body: ChatCompletionCreateParamsStreaming,\n    options?: Core.RequestOptions\n  ): Core.APIPromise<Stream<ChatCompletionChunk>>;\n  _create(\n    body: ChatCompletionCreateParams,\n    options?: Core.RequestOptions\n  ): Core.APIPromise<ChatCompletion | Stream<ChatCompletionChunk>> {\n    let resp: Core.APIPromise<ChatCompletion | Stream<ChatCompletionChunk>>;\n    resp = body.stream\n      ? super.create(body, options)\n      : super.create(body, options);\n    return resp;\n  }\n\n  create(\n    body: ChatCompletionCreateParamsNonStreaming & TromeroCompletionArgs,\n    options?: Core.RequestOptions\n  ): Core.APIPromise<ChatCompletion>;\n  create(\n    body: ChatCompletionCreateParamsStreaming & TromeroCompletionArgs,\n    options?: Core.RequestOptions\n  ): Core.APIPromise<MockStream>;\n  create(\n    body: ChatCompletionCreateParamsBase & TromeroCompletionArgs,\n    options?: Core.RequestOptions\n  ): Core.APIPromise<Stream<ChatCompletionChunk> | ChatCompletion>;\n  async create(\n    {\n      saveData,\n      tags,\n      ...body\n    }: ChatCompletionCreateParams & TromeroCompletionArgs,\n    options?: Core.RequestOptions\n  ): Promise<\n    ChatCompletion | MockStream | Stream<ChatCompletionChunk> | undefined\n  > {\n    const {\n      model,\n      use_fallback = true,\n      fallback_model = '',\n      ...kwargs\n    } = body as any;\n    const messages = this.formatMessages(kwargs.messages);\n    const { formattedKwargs, openAiKwargs } = await this.formatKwargs(kwargs);\n\n    let isOpenAiModel = await this.isModelFromOpenAi(model);\n\n    let res: ChatCompletion | Stream<ChatCompletionChunk> | MockStream;\n\n    if (isOpenAiModel) {\n      try {\n        if (body.stream) {\n          res = await this._create(body, options);\n          try {\n            return new MockStream(res, (response): Promise<string> => {\n              const dataToSend = {\n                messages: [...messages, response!.choices[0].message],\n                model,\n                kwargs: openAiKwargs,\n                creation_time: new Date().toISOString(),\n                tags: Array.isArray(tags)\n                  ? tags.join(', ')\n                  : typeof tags === 'string'\n                  ? tags\n                  : '',\n              };\n              console.log('dataToSend: ', dataToSend);\n\n              if (!saveData) return Promise.resolve('');\n              return this.saveDataOnServer(saveData, {\n                messages: [...messages, response!.choices[0].message],\n                model,\n                openAiKwargs,\n                creation_time: new Date().toISOString(),\n                tags: Array.isArray(tags)\n                  ? tags.join(', ')\n                  : typeof tags === 'string'\n                  ? tags\n                  : '',\n              });\n            });\n          } catch (e) {\n            console.error('Tromero: error creating Mock stream');\n            console.error(e);\n            throw e;\n          }\n        } else {\n          res = await this._create(body, options);\n          if (res.choices) {\n            for (const choice of res.choices) {\n              const formattedChoice = this.choiceToDict(choice);\n              const dataToSend = {\n                messages: messages.concat([formattedChoice.message]),\n                model,\n                kwargs: openAiKwargs,\n                creation_time: new Date().toISOString(),\n                tags: Array.isArray(tags)\n                  ? tags.join(', ')\n                  : typeof tags === 'string'\n                  ? tags\n                  : '',\n              };\n              console.log('dataToSend: ', dataToSend);\n\n              if (saveData) {\n                this.saveDataOnServer(saveData, {\n                  messages: messages.concat([formattedChoice.message]),\n                  model,\n                  kwargs: openAiKwargs,\n                  creation_time: new Date().toISOString(),\n                  tags: Array.isArray(tags)\n                    ? tags.join(', ')\n                    : typeof tags === 'string'\n                    ? tags\n                    : '',\n                });\n              }\n            }\n          }\n          return res;\n        }\n      } catch (error: unknown) {\n        if (error instanceof openai.APIError) {\n          const rawMessage = error.message as string | string[];\n          const message = Array.isArray(rawMessage)\n            ? rawMessage.join(', ')\n            : rawMessage;\n          console.warn('Error in create: ', message);\n          throw error;\n        }\n      }\n    } else {\n      if (this.tromeroClient && !(model in this.tromeroClient.modelUrls)) {\n        const { url, baseModel } = await this.tromeroClient.getModelUrl(model);\n        this.tromeroClient.modelUrls[model] = url;\n        this.tromeroClient.baseModel[model] = baseModel;\n      }\n\n      console.log('model url', this.tromeroClient?.modelUrls[model]);\n      console.log('model base', this.tromeroClient?.baseModel[model]);\n    }\n\n    //   const model_request_name = this.tromeroClient.baseModel[model]\n    //     ? 'NO_ADAPTER'\n    //     : model;\n\n    //   if (body.stream) {\n    //     const onData = (data: any) => {\n    //       if (saveData) {\n    //         this.saveDataOnServer(saveData, {\n    //           response: data,\n    //           model,\n    //           ...formattedKwargs,\n    //           creation_time: new Date().toISOString(),\n    //           tags,\n    //         });\n    //       }\n    //     };\n    //     const onError = async (error: Error) => {\n    //       if (use_fallback && fallback_model) {\n    //         const modifiedBody: ChatCompletionCreateParamsStreaming = {\n    //           ...body,\n    //           model: fallback_model,\n    //         };\n    //         res = await this._create(modifiedBody, options);\n    //       }\n    //       if (saveData) {\n    //         this.saveDataOnServer(saveData, {\n    //           response: res,\n    //           model,\n    //           ...formattedKwargs,\n    //           creation_time: new Date().toISOString(),\n    //           tags,\n    //         });\n    //       }\n    //     };\n    //     const onEnd = () => {};\n\n    //     res = await this.tromeroClient.createStream(\n    //       model_request_name,\n    //       this.tromeroClient.modelUrls[model],\n    //       messages,\n    //       formattedKwargs,\n    //       onData,\n    //       onError,\n    //       onEnd\n    //     );\n    //   } else {\n    //     try {\n    //       res = await this.tromeroClient.create(\n    //         model_request_name,\n    //         this.tromeroClient.modelUrls[model],\n    //         messages,\n    //         formattedKwargs\n    //       );\n\n    //       if (res.generated_text) {\n    //         res = mockOpenAIFormat(res.generated_text);\n    //       }\n    //     } catch (error) {\n    //       if (use_fallback && fallback_model) {\n    //         const modifiedBody: ChatCompletionCreateParamsNonStreaming = {\n    //           ...body,\n    //           model: fallback_model,\n    //         };\n    //         res = this._create(modifiedBody, options);\n    //       }\n    //     } finally {\n    //       if (saveData) {\n    //         this.saveDataOnServer(saveData, {\n    //           response: res,\n    //           model,\n    //           ...formattedKwargs,\n    //           creation_time: new Date().toISOString(),\n    //           tags,\n    //         });\n    //       }\n    //     }\n    //     return res;\n    //   }\n    // }\n  }\n}\n","import type {\n  ChatCompletion,\n  ChatCompletionChunk,\n} from 'openai/resources/chat';\nimport { Stream } from 'openai/streaming';\nimport mergeChunks from './mergeChunks';\n\n/**\n * A mock stream that saves the final completion to a file.\n * @param stream - The stream to mock.\n * @param saveData - The function to save the completion data.\n * @returns The mock stream.\n */\nexport class MockStream extends Stream<ChatCompletionChunk> {\n  private saveData: (response: ChatCompletion | null) => Promise<string>;\n\n  constructor(\n    stream: Stream<ChatCompletionChunk>,\n    saveData: (response: ChatCompletion | null) => Promise<string>\n  ) {\n    // @ts-expect-error - This is a private property but we need to access it\n    super(stream.iterator, stream.controller);\n    this.saveData = saveData;\n  }\n\n  async *[Symbol.asyncIterator](): AsyncIterator<\n    ChatCompletionChunk,\n    any,\n    undefined\n  > {\n    const iterator = super[Symbol.asyncIterator]();\n\n    let combinedResponse: ChatCompletion | null = null;\n    while (true) {\n      const result = await iterator.next();\n      if (result.done) break;\n      combinedResponse = mergeChunks(combinedResponse, result.value);\n\n      yield result.value;\n    }\n\n    await this.saveData(combinedResponse);\n  }\n}\n","import type {\n  ChatCompletion,\n  ChatCompletionChunk,\n  ChatCompletionMessage,\n  ChatCompletionMessageToolCall,\n} from 'openai/resources/chat';\n\n/**\n * Merges a new chunk into an existing completion.\n *\n * @param base - The existing completion to merge into.\n * @param chunk - The new chunk to merge.\n * @returns The merged completion.\n */\nexport default function mergeChunks(\n  base: ChatCompletion | null,\n  chunk: ChatCompletionChunk\n): ChatCompletion {\n  if (base === null) {\n    return mergeChunks(\n      { ...chunk, object: 'chat.completion', choices: [] },\n      chunk\n    );\n  }\n\n  const choices = [...base.choices];\n  for (const choice of chunk.choices) {\n    const baseChoice = choices.find((c) => c.index === choice.index);\n    if (baseChoice) {\n      baseChoice.finish_reason =\n        choice.finish_reason ?? baseChoice.finish_reason;\n      baseChoice.message = baseChoice.message ?? { role: 'assistant' };\n\n      if (choice.delta?.content) {\n        baseChoice.message.content =\n          (baseChoice.message.content ?? '') + (choice.delta.content ?? '');\n      }\n\n      if (choice.delta?.tool_calls) {\n        baseChoice.message.tool_calls = baseChoice.message.tool_calls ?? [];\n        baseChoice.message.tool_calls.push(\n          ...choice.delta.tool_calls.map(\n            (tc) =>\n              ({\n                ...tc,\n                id: tc.id ?? '',\n              } as ChatCompletionMessageToolCall)\n          )\n        );\n      }\n    } else {\n      choices.push({\n        index: choice.index,\n        finish_reason: choice.finish_reason ?? 'stop',\n        logprobs: choice.logprobs ?? null,\n        message: {\n          role: 'assistant',\n          ...choice.delta,\n          // tool_calls: choice.delta?.tool_calls?.map(\n          //   (tc) =>\n          //     ({\n          //       ...tc,\n          //       id: tc.id ?? '',\n          //     } as ChatCompletionMessageToolCall)\n          // ),\n        } as ChatCompletionMessage,\n      });\n    }\n  }\n\n  const merged: ChatCompletion = {\n    ...base,\n    choices,\n  };\n\n  return merged;\n}\n","import { ChatCompletionChunk } from 'openai/resources';\nimport { mockOpenAIFormatStream } from './tromeroUtils';\n\ninterface TromeroAIOptions {\n  apiKey: string;\n  baseURL?: string;\n  dataURL?: string;\n}\n\ninterface ApiResponse {\n  error?: string;\n  status_code: string | number;\n  [key: string]: any;\n}\n\nexport default class TromeroClient {\n  private dataURL: string;\n  private baseURL: string;\n  private apiKey: string;\n  modelUrls: { [key: string]: string };\n  baseModel: { [key: string]: any };\n\n  constructor({\n    apiKey,\n    baseURL = 'https://midyear-grid-402910.lm.r.appspot.com/tailor/v1',\n    dataURL = `${baseURL}/data`,\n  }: TromeroAIOptions) {\n    this.apiKey = apiKey;\n    this.dataURL = dataURL;\n    this.baseURL = baseURL;\n    this.modelUrls = {};\n    this.baseModel = {};\n  }\n\n  private async fetchData(\n    url: string,\n    options: RequestInit\n  ): Promise<ApiResponse> {\n    try {\n      const response = await fetch(url, options);\n      const data = await response.json();\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      return data;\n    } catch (error) {\n      if (error instanceof Error) {\n        return {\n          error: `An error occurred: ${error.message}`,\n          status_code: 'N/A',\n        };\n      }\n      return {\n        error: 'An error occurred',\n        status_code: 'N/A',\n      };\n    }\n  }\n\n  async postData(data: any): Promise<ApiResponse> {\n    return this.fetchData(this.dataURL, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'X-API-KEY': this.apiKey,\n      },\n      body: JSON.stringify(data),\n    });\n  }\n\n  async getModelUrl(modelName: string): Promise<ApiResponse> {\n    return this.fetchData(`${this.baseURL}/model/${modelName}/url`, {\n      method: 'GET',\n      headers: {\n        'X-API-KEY': this.apiKey,\n        'Content-Type': 'application/json',\n      },\n    });\n  }\n\n  mockOpenAIFormatStream(messages: string): any {\n    const choice = { delta: { content: messages } };\n    return { choices: [choice] };\n  }\n\n  async *streamResponse(\n    response: Response\n  ): AsyncGenerator<any, void, unknown> {\n    const reader = response.body?.getReader();\n    const decoder = new TextDecoder('utf-8');\n    let lastChunk = '';\n\n    if (reader) {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n\n        const chunkStr = decoder.decode(value);\n        lastChunk = chunkStr;\n\n        const pattern = /\"token\":({.*?})/;\n        const match = pattern.exec(chunkStr);\n\n        if (match) {\n          const json = JSON.parse(match[1]);\n          const formattedChunk = this.mockOpenAIFormatStream(json['text']);\n          yield formattedChunk;\n        } else {\n          break;\n        }\n      }\n    }\n  }\n\n  async create(\n    model: string,\n    modelUrl: string,\n    messages: any[],\n    parameters: any = {}\n  ): Promise<ApiResponse> {\n    return this.fetchData(`${modelUrl}/generate`, {\n      method: 'POST',\n      headers: {\n        'X-API-KEY': this.apiKey,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({ adapter_name: model, messages, parameters }),\n    });\n  }\n\n  // async createStream(\n  //   model: string,\n  //   modelUrl: string,\n  //   messages: any[],\n  //   parameters: { [key: string]: any },\n  //   onData: (data: any) => void,\n  //   onError: (error: Error) => void,\n  //   onEnd: () => void\n  // ) {\n  //   try {\n  //     const response = await fetch(`${modelUrl}/generate`, {\n  //       method: 'POST',\n  //       headers: {\n  //         'X-API-KEY': this.apiKey,\n  //         'Content-Type': 'application/json',\n  //       },\n  //       body: JSON.stringify({ messages, parameters, adapter_name: model }),\n  //     });\n\n  //     const reader = response.body?.getReader();\n  //     const decoder = new TextDecoder('utf-8');\n\n  //     if (reader) {\n  //       reader\n  //         .read()\n  //         .then(function process({ done, value }) {\n  //           if (done) {\n  //             onEnd();\n  //             return;\n  //           }\n\n  //           const chunk = decoder.decode(value, { stream: true });\n  //           onData(JSON.parse(chunk));\n\n  //           reader.read().then(process).catch(onError);\n  //         })\n  //         .catch(onError);\n  //     }\n  //   } catch (error) {\n  //     onError(error as Error);\n  //   }\n  // }\n\n  // async createStream(\n  //   model: string,\n  //   modelUrl: string,\n  //   messages: any[],\n  //   parameters: { [key: string]: any },\n  //   onData: (data: ChatCompletionChunk) => void,\n  //   onError: (error: Error) => void,\n  //   onEnd: () => void\n  // ) {\n  //   try {\n  //     const response = await fetch(`${modelUrl}/generate_stream`, {\n  //       method: 'POST',\n  //       headers: {\n  //         'X-API-KEY': this.apiKey,\n  //         'Content-Type': 'application/json',\n  //       },\n  //       body: JSON.stringify({ messages, parameters, adapter_name: model }),\n  //     });\n\n  //     if (!response.ok) {\n  //       throw new Error(`HTTP error! status: ${response.status}`);\n  //     }\n\n  //     const reader = response.body?.getReader();\n  //     const decoder = new TextDecoder('utf-8');\n\n  //     if (reader) {\n  //       let buffer = '';\n\n  //       const process = async ({\n  //         done,\n  //         value,\n  //       }: ReadableStreamDefaultReadResult<Uint8Array>) => {\n  //         if (done) {\n  //           onEnd();\n  //           return;\n  //         }\n\n  //         buffer += decoder.decode(value, { stream: true });\n  //         const parts = buffer.split('\\n');\n  //         buffer = parts.pop()!; // Keep the last incomplete part in the buffer\n\n  //         for (const part of parts) {\n  //           if (part.startsWith('data:')) {\n  //             try {\n  //               const jsonStr = part.substring(5);\n  //               const data = JSON.parse(jsonStr);\n  //               if (data.token && data.token.text) {\n  //                 const formattedChunk: ChatCompletionChunk = {\n  //                   choices: [\n  //                     {\n  //                       finish_reason: null,\n  //                       index: 0,\n  //                       delta: {\n  //                         content: data.token.text,\n  //                       },\n  //                     },\n  //                   ],\n  //                   id: '',\n  //                   created: 0,\n  //                   model: '',\n  //                   object: 'chat.completion.chunk',\n  //                 };\n  //                 onData(formattedChunk);\n  //               }\n  //             } catch (error) {\n  //               console.error('Error parsing JSON data:', error);\n  //             }\n  //           }\n  //         }\n\n  //         reader.read().then(process).catch(onError);\n  //       };\n\n  //       reader.read().then(process).catch(onError);\n  //     } else {\n  //       onEnd();\n  //     }\n  //   } catch (error) {\n  //     onError(error as Error);\n  //   }\n  // }\n}\n"],"mappings":"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","names":["_a","_b","_a"]}